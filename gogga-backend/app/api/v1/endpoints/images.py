"""
Image Generation API - Tier-Based Pipeline.

FREE Tier:
    User → Qwen 235B FREE (enhance) → LongCat Flash FREE → Image
    
JIVE/JIGGA Tier:
    User → Qwen 235B FREE (enhance) → FLUX 1.1 Pro → Image

Prompt enhancement is ALWAYS via OpenRouter Qwen 3 235B FREE.
"""

import logging
from typing import Any

from fastapi import APIRouter, HTTPException, status
from pydantic import BaseModel, Field

from app.core.router import UserTier, IMAGE_LIMITS, is_image_prompt
from app.services.image_service import image_service
from app.services.openrouter_service import openrouter_service
from app.services.posthog_service import posthog_service

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/images", tags=["Images"])


class ImageGenerateRequest(BaseModel):
    """Request body for image generation."""
    prompt: str = Field(
        ...,
        min_length=1,
        max_length=4000,
        description="Text description of the desired image"
    )
    user_id: str | None = Field(default=None)
    user_tier: UserTier = Field(
        default=UserTier.FREE,
        description="User's subscription tier (free, jive, jigga)"
    )
    size: str = Field(
        default="1024x1024",
        description="Image dimensions (GOGGA Pro only)",
        pattern=r"^\d+x\d+$"
    )
    enhance_prompt: bool = Field(
        default=True,
        description="Use Qwen 3 235B to enhance prompt before generation"
    )
    use_premium: bool = Field(
        default=True,
        description="Use GOGGA Pro (FLUX 1.1) for premium quality. False uses Pollinations.ai (free)"
    )


class ImageGenerateResponse(BaseModel):
    """Response body for image generation."""
    success: bool = True
    original_prompt: str
    enhanced_prompt: str
    image_data: str  # Base64 for FLUX, content for LongCat
    size: str | None = None
    meta: dict[str, Any] = {}


@router.post(
    "/generate",
    response_model=ImageGenerateResponse,
    status_code=status.HTTP_200_OK,
    summary="Generate an image based on user tier"
)
async def generate_image(request: ImageGenerateRequest) -> ImageGenerateResponse:
    """
    Generate an image based on user tier.
    
    **FREE Tier:**
    - Prompt enhanced by Qwen 3 235B FREE
    - Image generated by Pollinations.ai (FREE)
    - Limit: 50 images/month
    
    **JIVE Tier (use_premium=False / Tool Calling):**
    - Prompt enhanced by Qwen 3 235B FREE
    - Image generated by Pollinations.ai (FREE)
    - Limit: 200 images/month
    
    **JIVE/JIGGA Tier (use_premium=True / Image Button):**
    - Prompt enhanced by Qwen 3 235B FREE
    - Image generated by GOGGA Pro (FLUX 1.1 Pro) - Premium quality
    - Limit: 200/1000 images/month
    
    Named after Irma Stern, pioneering South African expressionist painter.
    """
    try:
        # FREE tier always uses Pollinations, paid tiers check use_premium flag
        use_premium = request.use_premium and request.user_tier != UserTier.FREE
        
        result = await image_service.generate_image(
            prompt=request.prompt,
            user_id=request.user_id,
            user_tier=request.user_tier,
            size=request.size,
            enhance_prompt=request.enhance_prompt,
            use_premium=use_premium,
        )
        
        # Track successful image generation (non-blocking)
        generator = "gogga-pro" if use_premium else "pollinations"
        await posthog_service.track_image(
            user_id=request.user_id or "anonymous",
            tier=request.user_tier.value,
            model=result.meta.get("generator", generator),
            prompt_length=len(request.prompt),
            latency_seconds=result.meta.get("latency_seconds", 0),
            success=True
        )
        
        return ImageGenerateResponse(
            success=True,
            original_prompt=result.original_prompt,
            enhanced_prompt=result.enhanced_prompt,
            image_data=result.image_data,
            size=result.size,
            meta=result.meta,
        )
        
    except Exception as e:
        logger.exception("Image generation error")
        posthog_service.capture_error(
            user_id=request.user_id or "anonymous",
            error_type="image_generation_error",
            error_message=str(e),
            context={"tier": request.user_tier.value, "endpoint": "images/generate"}
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Image generation failed: {str(e)}"
        )


@router.post(
    "/enhance-prompt",
    summary="Enhance an image prompt (FREE for all tiers)"
)
async def enhance_prompt(prompt: str) -> dict[str, Any]:
    """
    Enhance a prompt using Qwen 3 235B FREE.
    
    This is FREE for ALL tiers - the universal "Enhance" button.
    
    Returns all three versions: original, structured, enhanced.
    """
    try:
        result = await openrouter_service.enhance_prompt(prompt)
        return {
            "success": True,
            **result
        }
    except Exception as e:
        logger.exception("Prompt enhancement error")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Prompt enhancement failed: {str(e)}"
        )


@router.get(
    "/detect",
    summary="Detect if a prompt is an image request"
)
async def detect_image_intent(prompt: str) -> dict:
    """
    Detect if a prompt is requesting image generation.
    
    Uses keyword matching to route:
    - Image prompts → /api/v1/images/generate
    - Text prompts → /api/v1/chat
    """
    is_image = is_image_prompt(prompt)
    return {
        "prompt": prompt,
        "is_image_request": is_image,
        "suggested_endpoint": "/api/v1/images/generate" if is_image else "/api/v1/chat"
    }


@router.get(
    "/limits",
    summary="Get image generation limits per tier"
)
async def get_limits() -> dict:
    """Get image generation limits for each tier."""
    return {
        "limits": {
            "free": {
                "images_per_month": IMAGE_LIMITS[UserTier.FREE],
                "generator": "LongCat Flash",
                "cost": "FREE"
            },
            "jive": {
                "images_per_month": IMAGE_LIMITS[UserTier.JIVE],
                "generator": "FLUX 1.1 Pro",
                "cost": "Included in subscription"
            },
            "jigga": {
                "images_per_month": IMAGE_LIMITS[UserTier.JIGGA],
                "generator": "FLUX 1.1 Pro",
                "cost": "Included in subscription"
            }
        },
        "prompt_enhancement": {
            "model": "Qwen 3 235B",
            "provider": "OpenRouter",
            "cost": "FREE (all tiers)"
        }
    }


@router.get(
    "/health",
    summary="Check image service health"
)
async def image_health() -> dict:
    """Check if image services are configured and ready."""
    from app.config import get_settings
    settings = get_settings()
    
    # Check OpenRouter
    openrouter_health = await openrouter_service.health_check()
    
    return {
        "status": "healthy",
        "services": {
            "prompt_enhancement": {
                "provider": "OpenRouter",
                "status": openrouter_health.get("status", "unknown"),
                "model": settings.OPENROUTER_MODEL_QWEN,
                "cost": "FREE"
            },
            "free_generation": {
                "provider": "OpenRouter",
                "model": settings.OPENROUTER_MODEL_LONGCAT,
                "cost": "FREE"
            },
            "pro_generation": {
                "provider": "DeepInfra",
                "status": "configured" if settings.DEEPINFRA_API_KEY else "unconfigured",
                "model": settings.DEEPINFRA_IMAGE_MODEL
            }
        }
    }


# =============================================================================
# Imagen Edit/Upscale Endpoints (JIVE/JIGGA Only)
# =============================================================================

class ImageEditRequest(BaseModel):
    """Request body for image editing (inpaint/outpaint)."""
    prompt: str = Field(
        ...,
        min_length=1,
        max_length=2000,
        description="Edit instruction (what to add/remove/change)"
    )
    source_image: str = Field(
        ...,
        description="Base64-encoded source image"
    )
    mask_image: str | None = Field(
        default=None,
        description="Base64-encoded mask (white=edit area, black=preserve)"
    )
    edit_mode: str = Field(
        default="EDIT_MODE_INPAINT_INSERTION",
        description="Edit mode: EDIT_MODE_INPAINT_INSERTION, EDIT_MODE_INPAINT_REMOVAL, EDIT_MODE_OUTPAINT, EDIT_MODE_BGSWAP"
    )
    user_id: str | None = Field(default=None)
    user_tier: UserTier = Field(default=UserTier.JIVE)
    idempotency_key: str | None = Field(
        default=None,
        description="UUID v4 for request deduplication"
    )


class ImageEditResponse(BaseModel):
    """Response body for image editing."""
    success: bool = True
    edited_images: list[str] = Field(
        default_factory=list,
        description="Base64-encoded edited images"
    )
    prompt: str
    edit_mode: str
    meta: dict[str, Any] = {}
    error: str | None = None


class ImageUpscaleRequest(BaseModel):
    """Request body for image upscaling."""
    source_image: str = Field(
        ...,
        description="Base64-encoded source image"
    )
    upscale_factor: str = Field(
        default="x2",
        pattern=r"^x[234]$",
        description="Upscale factor: x2, x3, or x4"
    )
    user_id: str | None = Field(default=None)
    user_tier: UserTier = Field(default=UserTier.JIVE)
    idempotency_key: str | None = Field(
        default=None,
        description="UUID v4 for request deduplication"
    )


class ImageUpscaleResponse(BaseModel):
    """Response body for image upscaling."""
    success: bool = True
    upscaled_image: str = Field(
        default="",
        description="Base64-encoded upscaled image"
    )
    upscale_factor: str
    meta: dict[str, Any] = {}
    error: str | None = None


@router.post(
    "/edit",
    response_model=ImageEditResponse,
    status_code=status.HTTP_200_OK,
    summary="Edit an image using Imagen 3.0 (JIVE/JIGGA only)"
)
async def edit_image(request: ImageEditRequest) -> ImageEditResponse:
    """
    Edit an existing image using Vertex AI Imagen 3.0.
    
    **Requires JIVE or JIGGA tier.**
    
    **Edit Modes:**
    - EDIT_MODE_INPAINT_INSERTION: Add new elements to masked areas
    - EDIT_MODE_INPAINT_REMOVAL: Remove objects from masked areas
    - EDIT_MODE_OUTPAINT: Extend image canvas
    - EDIT_MODE_BGSWAP: Replace background
    
    **Usage:**
    1. Generate a mask (white = areas to edit, black = preserve)
    2. Provide source image + mask + prompt
    3. Imagen will edit only the masked regions
    
    **Limits:**
    - JIVE: 20 edits/month
    - JIGGA: 100 edits/month
    """
    from app.services.imagen_service import ImagenService, ImagenRequest, ImagenOperation
    
    # Require paid tier
    if request.user_tier == UserTier.FREE:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Image editing requires JIVE or JIGGA subscription"
        )
    
    try:
        imagen = ImagenService()
        imagen_request = ImagenRequest(
            prompt=request.prompt,
            operation=ImagenOperation.EDIT,
            source_image=request.source_image,
            mask_image=request.mask_image,
            edit_mode=request.edit_mode,
            idempotency_key=request.idempotency_key,
        )
        
        response = await imagen.edit(
            request=imagen_request,
            user_id=request.user_id,
            user_tier=request.user_tier,
        )
        
        if not response.success:
            return ImageEditResponse(
                success=False,
                prompt=request.prompt,
                edit_mode=request.edit_mode,
                error=response.error,
            )
        
        return ImageEditResponse(
            success=True,
            edited_images=response.images,
            prompt=request.prompt,
            edit_mode=request.edit_mode,
            meta=response.meta,
        )
        
    except Exception as e:
        logger.exception("Image edit error")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Image editing failed: {str(e)}"
        )


@router.post(
    "/upscale",
    response_model=ImageUpscaleResponse,
    status_code=status.HTTP_200_OK,
    summary="Upscale an image using Imagen (JIVE/JIGGA only)"
)
async def upscale_image(request: ImageUpscaleRequest) -> ImageUpscaleResponse:
    """
    Upscale an image using Vertex AI Imagen.
    
    **Requires JIVE or JIGGA tier.**
    
    **Upscale Factors:**
    - x2: 2x resolution (e.g., 512x512 → 1024x1024)
    - x3: 3x resolution (JIGGA only)
    - x4: 4x resolution (JIGGA only)
    
    **Limits:**
    - JIVE: 20 upscales/month (x2 only)
    - JIGGA: 50 upscales/month (x2, x3, x4)
    """
    from app.services.imagen_service import ImagenService, ImagenRequest, ImagenOperation
    
    # Require paid tier
    if request.user_tier == UserTier.FREE:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Image upscaling requires JIVE or JIGGA subscription"
        )
    
    # x3 and x4 require JIGGA
    if request.upscale_factor in ("x3", "x4") and request.user_tier != UserTier.JIGGA:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Upscale factor {request.upscale_factor} requires JIGGA subscription"
        )
    
    try:
        imagen = ImagenService()
        imagen_request = ImagenRequest(
            prompt="upscale",  # Placeholder, not used for upscaling
            operation=ImagenOperation.UPSCALE,
            source_image=request.source_image,
            upscale_factor=request.upscale_factor,
            idempotency_key=request.idempotency_key,
        )
        
        response = await imagen.upscale(
            request=imagen_request,
            user_id=request.user_id,
            user_tier=request.user_tier,
        )
        
        if not response.success:
            return ImageUpscaleResponse(
                success=False,
                upscale_factor=request.upscale_factor,
                error=response.error,
            )
        
        return ImageUpscaleResponse(
            success=True,
            upscaled_image=response.images[0] if response.images else "",
            upscale_factor=request.upscale_factor,
            meta=response.meta,
        )
        
    except Exception as e:
        logger.exception("Image upscale error")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Image upscaling failed: {str(e)}"
        )
